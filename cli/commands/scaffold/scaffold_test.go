package scaffold_test

import (
	"os"
	"path/filepath"
	"testing"

	boilerplateoptions "github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/templates"
	"github.com/gruntwork-io/boilerplate/variables"
	"github.com/gruntwork-io/terragrunt/cli/commands/scaffold"
	"github.com/gruntwork-io/terragrunt/config"
	"github.com/gruntwork-io/terragrunt/options"
	"github.com/gruntwork-io/terragrunt/test/helpers/logger"
	"github.com/gruntwork-io/terragrunt/util"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestDefaultTemplateVariables(t *testing.T) {
	t.Parallel()

	// set pre-defined variables
	vars := map[string]any{}
	var requiredVariables, optionalVariables []*config.ParsedVariable

	requiredVariables = append(requiredVariables, &config.ParsedVariable{
		Name:                    "required_var_1",
		Description:             "required_var_1 description",
		Type:                    "string",
		DefaultValuePlaceholder: "\"\"",
	})

	optionalVariables = append(optionalVariables, &config.ParsedVariable{
		Name:         "optional_var_2",
		Description:  "optional_ver_2 description",
		Type:         "number",
		DefaultValue: "42",
	})

	vars["requiredVariables"] = requiredVariables
	vars["optionalVariables"] = optionalVariables

	vars["sourceUrl"] = "git::https://github.com/gruntwork-io/terragrunt.git//test/fixtures/inputs?ref=v0.53.8"

	vars["EnableRootInclude"] = false
	vars["RootFileName"] = "root.hcl"

	workDir := t.TempDir()
	templateDir := util.JoinPath(workDir, "template")
	err := os.Mkdir(templateDir, 0755)
	require.NoError(t, err)

	outputDir := util.JoinPath(workDir, "output")
	err = os.Mkdir(outputDir, 0755)
	require.NoError(t, err)

	err = os.WriteFile(util.JoinPath(templateDir, "terragrunt.hcl"), []byte(scaffold.DefaultTerragruntTemplate), 0644)
	require.NoError(t, err)

	err = os.WriteFile(util.JoinPath(templateDir, "boilerplate.yml"), []byte(scaffold.DefaultBoilerplateConfig), 0644)
	require.NoError(t, err)

	boilerplateOpts := &boilerplateoptions.BoilerplateOptions{
		OutputFolder:    outputDir,
		OnMissingKey:    boilerplateoptions.DefaultMissingKeyAction,
		OnMissingConfig: boilerplateoptions.DefaultMissingConfigAction,
		Vars:            vars,
		DisableShell:    true,
		DisableHooks:    true,
		NonInteractive:  true,
		TemplateFolder:  templateDir,
	}

	emptyDep := variables.Dependency{}
	err = templates.ProcessTemplate(boilerplateOpts, boilerplateOpts, emptyDep)
	require.NoError(t, err)

	content, err := util.ReadFileAsString(filepath.Join(outputDir, "terragrunt.hcl"))
	require.NoError(t, err)
	require.Contains(t, content, "required_var_1")
	require.Contains(t, content, "optional_var_2")

	// read generated HCL file and check if it is parsed correctly
	opts, err := options.NewTerragruntOptionsForTest(filepath.Join(outputDir, "terragrunt.hcl"))
	require.NoError(t, err)

	l := logger.CreateLogger()

	cfg, err := config.ReadTerragruntConfig(t.Context(), l, opts, config.DefaultParserOptions(l, opts))
	require.NoError(t, err)
	require.NotEmpty(t, cfg.Inputs)
	assert.Len(t, cfg.Inputs, 1)
	_, found := cfg.Inputs["required_var_1"]
	require.True(t, found)
	require.Equal(t, "git::https://github.com/gruntwork-io/terragrunt.git//test/fixtures/inputs?ref=v0.53.8", *cfg.Terraform.Source)
}

// TestScaffoldFeatures validates shell and hooks behavior using a table-driven approach.
// This consolidates testing of both --enable-shell and --enable-hooks flags with their positive and negative cases.
func TestScaffoldFeatures(t *testing.T) {
	t.Parallel()

	// Reusable templates
	shellTestTemplate := `terraform {
  source = "{{ .sourceUrl }}"
}

# Shell command result: {{shell "echo" "SHELL_SUCCESS"}}`

	hooksTestTemplate := `terraform {
  source = "{{ .sourceUrl }}"
}

# Generated by hooks test`

	// Reusable boilerplate configs
	basicConfig := `variables:
  - name: sourceUrl
    type: string`

	hooksConfig := `variables:
  - name: sourceUrl
    type: string

hooks:
  before:
    - command: echo
      args: ["Before hook executed"]
      description: Runs before template processing
  after:
    - command: echo
      args: ["After hook executed"]  
      description: Runs after template processing`

	tests := []struct {
		name                 string
		description          string
		disableShell         bool
		disableHooks         bool
		template             string
		boilerplateConfig    string
		expectedInContent    []string
		expectedNotInContent []string
	}{
		{
			name:                 "shell enabled",
			description:          "validates shell commands execute when --enable-shell flag is used",
			disableShell:         false,
			disableHooks:         true,
			template:             shellTestTemplate,
			boilerplateConfig:    basicConfig,
			expectedInContent:    []string{"SHELL_SUCCESS"},
			expectedNotInContent: []string{"replace-me"},
		},
		{
			name:                 "shell disabled",
			description:          "validates shell commands are blocked when shell execution is disabled by default",
			disableShell:         true,
			disableHooks:         true,
			template:             shellTestTemplate,
			boilerplateConfig:    basicConfig,
			expectedInContent:    []string{"replace-me"},
			expectedNotInContent: []string{"SHELL_SUCCESS"},
		},
		{
			name:                 "hooks enabled",
			description:          "validates boilerplate hooks execute when --enable-hooks flag is used",
			disableShell:         true,
			disableHooks:         false,
			template:             hooksTestTemplate,
			boilerplateConfig:    hooksConfig,
			expectedInContent:    []string{"Generated by hooks test"},
			expectedNotInContent: []string{},
		},
		{
			name:                 "hooks disabled",
			description:          "validates boilerplate hooks are skipped when hooks are disabled by default",
			disableShell:         true,
			disableHooks:         true,
			template:             hooksTestTemplate,
			boilerplateConfig:    hooksConfig,
			expectedInContent:    []string{"Generated by hooks test"},
			expectedNotInContent: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			t.Parallel()

			workDir := t.TempDir()
			templateDir := util.JoinPath(workDir, "template")
			outputDir := util.JoinPath(workDir, "output")

			require.NoError(t, os.Mkdir(templateDir, 0755))
			require.NoError(t, os.Mkdir(outputDir, 0755))

			// Basic variables needed for scaffold template processing
			vars := map[string]any{
				"sourceUrl":         "git::https://github.com/gruntwork-io/terragrunt.git//test/fixtures/inputs?ref=v0.53.8",
				"EnableRootInclude": false,
				"RootFileName":      "root.hcl",
			}

			// Write template files using test case data
			require.NoError(t, os.WriteFile(util.JoinPath(templateDir, "terragrunt.hcl"), []byte(tt.template), 0644))
			require.NoError(t, os.WriteFile(util.JoinPath(templateDir, "boilerplate.yml"), []byte(tt.boilerplateConfig), 0644))

			// Configure boilerplate options based on test case
			boilerplateOpts := &boilerplateoptions.BoilerplateOptions{
				OutputFolder:    outputDir,
				OnMissingKey:    boilerplateoptions.DefaultMissingKeyAction,
				OnMissingConfig: boilerplateoptions.DefaultMissingConfigAction,
				Vars:            vars,
				DisableShell:    tt.disableShell,
				DisableHooks:    tt.disableHooks,
				NonInteractive:  true,
				TemplateFolder:  templateDir,
			}

			// Process template
			emptyDep := variables.Dependency{}
			require.NoError(t, templates.ProcessTemplate(boilerplateOpts, boilerplateOpts, emptyDep))

			// Verify expected content based on test case
			terragruntPath := filepath.Join(outputDir, "terragrunt.hcl")
			content, err := util.ReadFileAsString(terragruntPath)
			require.NoError(t, err)

			// Check for expected content
			for _, expected := range tt.expectedInContent {
				require.Contains(t, content, expected, "Expected content should be present in generated file")
			}

			// Check that unexpected content is not present
			for _, unexpected := range tt.expectedNotInContent {
				require.NotContains(t, content, unexpected, "Unexpected content should not be present in generated file")
			}

			// Verify source URL is always interpolated correctly
			require.Contains(t, content, vars["sourceUrl"], "Template variables should be interpolated correctly")
		})
	}
}
